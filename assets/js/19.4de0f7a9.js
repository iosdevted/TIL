(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{383:function(e,t,a){"use strict";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"value-semantics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#value-semantics"}},[e._v("#")]),e._v(" Value Semantics")]),e._v(" "),a("p",[e._v("Types in Swift fall into one of two categories: first, “value types”, where each instance keeps a unique copy of its data, usually defined as a "),a("code",[e._v("struct")]),e._v(", "),a("code",[e._v("enum")]),e._v(", or "),a("code",[e._v("tuple")]),e._v(". The second, “reference types”, where instances share a single copy of the data, and the type is usually defined as a "),a("code",[e._v("class")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"reference-types-vs-value-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reference-types-vs-value-types"}},[e._v("#")]),e._v(" Reference Types vs Value Types")]),e._v(" "),a("p",[e._v("The most basic distinguishing feature of a value type is that copying — the effect of assignment, initialization, and argument passing — creates an independent instance with its own unique copy of its data:")]),e._v(" "),a("div",{staticClass:"language-swift extra-class"},[a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("MyValueType")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("Int")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("V1")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("MyValueType")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("V2")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("V1")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("V2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("V1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v('// Prints "MyValueType(a: 1)"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("V2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v('// Prints "MyValueType(a: 42)"')]),e._v("\n")])])]),a("p",[e._v("Copying a reference, on the other hand, implicitly creates a shared instance. After a copy, two variables then refer to a single instance of the data, so modifying data in the second variable also affects the original, e.g.:")]),e._v(" "),a("div",{staticClass:"language-swift extra-class"},[a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyReferenceType")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("Int")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("Int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" a\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("R1")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("MyReferenceType")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("R2")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("R1")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("R2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("R1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("R2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v('// Prints "42 42"')]),e._v("\n")])])]),a("p",[e._v("One of the primary reasons to choose value types over reference types is the ability to more easily reason about your code. If you always get a unique, copied instance, you can trust that no other part of your app is changing the data under the covers. This is especially helpful in multi-threaded environments where a different thread could alter your data out from under you. This can create nasty bugs that are extremely hard to debug.")]),e._v(" "),a("p",[a("strong",[e._v("Use a value type when:")])]),e._v(" "),a("ul",[a("li",[e._v("Comparing instance data with "),a("code",[e._v("==")]),e._v(" makes sense")]),e._v(" "),a("li",[e._v("You want copies to have independent state")]),e._v(" "),a("li",[e._v("The data will be used in code across multiple threads\n"),a("br"),e._v(" "),a("br")])]),e._v(" "),a("p",[a("strong",[e._v("Use a reference type (e.g. use a "),a("code",[e._v("class")]),e._v(") when")]),e._v(":")]),e._v(" "),a("ul",[a("li",[e._v("Comparing instance identity with "),a("code",[e._v("===")]),e._v(" makes sense")]),e._v(" "),a("li",[e._v("You want to create shared, mutable state\n"),a("br"),e._v(" "),a("br")])]),e._v(" "),a("p",[e._v("In Swift, "),a("code",[e._v("Array")]),e._v(", "),a("code",[e._v("String")]),e._v(", and "),a("code",[e._v("Dictionary")]),e._v(" are all value types. They behave much like a simple "),a("code",[e._v("int")]),e._v(" value in C, acting as a unique instance of that data. You don’t need to do anything special — such as making an explicit copy — to prevent other code from modifying that data behind your back. Importantly, you can safely pass copies of values across threads without synchronization. In the spirit of improving safety, this model will help you write more predictable code in Swift.")]),e._v(" "),a("h2",{attrs:{id:"reference-semantics-vs-value-semantics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reference-semantics-vs-value-semantics"}},[e._v("#")]),e._v(" Reference Semantics vs Value Semantics")]),e._v(" "),a("p",[e._v("With value semantics, a variable and the data assigned to the variable are logically unified. Since variables exist on the stack, value types in Swift are said to be stack-allocated. To be precise, all value type instances will not always be on the stack. Some may exist only in CPU registers while others may actually be allocated on the heap. In a logical sense though, value type instances can be thought of as being contained in the variables to which they are assigned. There is a one-to-one relationship between the variable and the data. The value held by a variable cannot be manipulated independently of the variable.")]),e._v(" "),a("p",[e._v("With reference semantics, on the other hand, the variable and the data are distinct. Reference type instances are allocated on the heap and the variable contains only a reference to the location in memory where the data is stored. It is possible and quite common for there to be multiple variables with references to the same instance. Any of these references can be used to manipulate the instance.")]),e._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("p",[e._v("More information on Markdown can be found at the following links:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://medium.com/@JimmyMAndersson/understanding-swift-value-semantics-d84d57b937a2",target:"_blank",rel:"noopener noreferrer"}},[e._v("Medium - Understanding Swift Value Semantics"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.raywenderlich.com/9481-reference-vs-value-types-in-swift",target:"_blank",rel:"noopener noreferrer"}},[e._v("Raywnderlich - Reference vs Value Types in Swift"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://khawerkhaliq.com/blog/swift-value-types-reference-types/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Blog - When and How to use Value and Reference Types in Swift"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://developer.apple.com/swift/blog/?id=10",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apple Developer - Value and Reference Types"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://hackernoon.com/semantics-in-swift-66d1c19b33f1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Hackernoon - Semantics in Swift"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Swiftbysundell - Utilizing value semantics in Swift"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);