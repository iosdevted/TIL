(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{383:function(e,t,r){"use strict";r.r(t);var n=r(42),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"strong-reference-cycles-strong-weak-unowned"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#strong-reference-cycles-strong-weak-unowned"}},[e._v("#")]),e._v(" Strong Reference Cycles; strong, weak, unowned")]),e._v(" "),r("p",[e._v("ARC의 한가지 문제점이라 하면 두 개의 객체가 상호 참조하는 경우와 같은\n강한 순환 참조가 만들어 질 수 있다는 점이다.\n이렇게 되면 이 순환 참조에 연관된 객체들은 레퍼런스 카운트가\n0에 도달하지 않게 되어 메모리 누수가 발생하게 된다.")]),e._v(" "),r("p",[e._v("스위프트와 같이 ARC를 기반으로 하는 메모리 관리 모델에서는\n어떻게 하면 강한 순환 참조를 발생시키지 않도록 하느냐가\n메모리 관리상의 가장 큰 관심사가 된다.")]),e._v(" "),r("p",[e._v("강한 순환 참조에 대해서 쉽게 설명하면\nA와 B가 있는데 서로 멱살을 잡고(참조) 있다.\n둘 중 누가 먼저 멱살을 놓기 시작(참조 해제) 해야\n이 험악한 상황이 종료(메모리 할당 해제) 될텐데\n계속 서로 멱살을 안 놓다 보니 험악한 상황(메모리 누수)이 지속되고 있는 것이다.\n이 상황이 바로 강한 순환 참조를 뜻한다.")]),e._v(" "),r("p",[e._v("강한순환참조를 해결하기 위해 이러한 관계 속에서 weak, unowned를 정의할 수 있습니다. 이 과정은 이후 설명되어질 주제, "),r("a",{attrs:{href:"https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID52",target:"_blank",rel:"noopener noreferrer"}},[e._v("Resolving Strong Reference Cycles Between Class Instances"),r("OutboundLink")],1),e._v("에서 설명되어집니다만, 강한순환참조를 해결하는 방법에 대해 배우기 전에 왜 참조순환이 발생하는지 이해하는 것은 매우 유용하니 참고 하시기 바랍니다.")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th"),e._v(" "),r("th",[e._v("strong")]),e._v(" "),r("th",[e._v("weak")]),e._v(" "),r("th",[e._v("unowned")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("Reference Counting")]),e._v(" "),r("td",[e._v("O")]),e._v(" "),r("td",[e._v("X")]),e._v(" "),r("td",[e._v("X")])]),e._v(" "),r("tr",[r("td",[e._v("사용 시점")]),e._v(" "),r("td",[e._v("Default")]),e._v(" "),r("td",[e._v("강한 순환 참조가 발생할 경우")]),e._v(" "),r("td",[e._v("강한 순환 참조가 발생할 경우, 참조하는 인스턴스가 먼저 메모리에서 해제될 가능성이 없는 경우")])]),e._v(" "),r("tr",[r("td",[e._v("특징")]),e._v(" "),r("td",[e._v("강한 순환 참조로 인해 Memory leak이 발생할 수 있음")]),e._v(" "),r("td",[e._v("참조하던 인스턴스가 해제되면 자동으로 nil을 할당")]),e._v(" "),r("td",[e._v("참조하던 인스턴스가 먼제 메모리에서 해제되면, 헤재된 주소값을 계속 들고 있음(에러로 이어질 가능성이 높음)")])])])]),e._v(" "),r("h2",{attrs:{id:"delegate-순환참조"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#delegate-순환참조"}},[e._v("#")]),e._v(" Delegate 순환참조")]),e._v(" "),r("div",{staticClass:"language-swift extra-class"},[r("pre",{pre:!0,attrs:{class:"language-swift"}},[r("code",[e._v("vc"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("delegate "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("self")]),e._v("\n")])])]),r("p",[e._v("delegate를 하기 위해서는 일을 시키는 객체와 일을 하는 객체 두 개가 무조건 있어야 하는데, 위의 코드로 객체를 연결시켜줌으로 인해 FirstViewController와 SecondViewController는 서로를 소유하는 상황이 됩니다.")]),e._v(" "),r("p",[e._v("즉, 다시 말해 FirstViewController에서 SecondViewController 객체를 만듦으로 SecondViewController를 소유하고,\nSecondViewController의 delegate를 FirstViewController로 연결해줌으로써 FirstViewController를 소유하는 순환참조가 됩니다.")]),e._v(" "),r("p",[e._v("이 문제를 해결하기 위해서는 "),r("code",[e._v("SecondViewController의 delegate에 weak를 붙이면 되는데")]),e._v(" 그렇게 되면")]),e._v(" "),r("p",[e._v("FirstViewController만 SecondViewController를 소유하기 때문에 순환참조가 발생하지 않게 됩니다.")]),e._v(" "),r("h2",{attrs:{id:"references"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID52",target:"_blank",rel:"noopener noreferrer"}},[e._v("Resolving Strong Reference Cycles Between Class Instances"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://babbab2.tistory.com/26?category=831129",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS) 메모리 관리 (2/3) - strong , weak, unowned, 순환 참조"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://0urtrees.tistory.com/67",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS 개발문서 - 강한순환참조(strong reference cycle) 문제"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://shark-sea.kr/entry/iOS-ARC-strong-weak-unowned",target:"_blank",rel:"noopener noreferrer"}},[e._v("상어의 개발 블로그 - iOS::ARC, strong, weak, unowned"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=o.exports}}]);